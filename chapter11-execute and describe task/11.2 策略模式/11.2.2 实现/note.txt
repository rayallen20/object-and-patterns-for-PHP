当类必须支持同一个接口的多种实现时(比如现在正在解决的每个类的mark()方法)，
最好的办法是提取这些实现，并将它们放置在自己的类型中，而不是通过继承原有的类去支持这些实现。
个人对这句话的理解:
当类必须支持同一个接口的多种实现时，不是通过继承原有的类去支持这些实现:
从图11-4来看，正是因为要支持mark()方法的多种实现，才让继承体系中的类变的这么多。
最好的办法是提取这些实现，并将他们放置在自己的类型中:
好的做法是将算法从业务类中抽离出来，单独形成一套继承体系。业务类和算法类之间形成聚合关系。
一句话概括:当算法(同一接口的不同实现)在每个业务类的子类中都有其单独的实现，
甚至因为算法的不同而导致业务类的继承体系中子类数量过多时，应将接口抽离出来，
单独形成自己的一套继承体系。这种算法类和业务类之间的关系，称为策略模式。
这样做的好处在于算法的变化独立于使用算法的客户端代码，即算法的变化不依赖于业务类。
解耦了算法和业务之间的关系。而且也印证了:组合优于继承。

Head First图对策略模式的概括:
定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

算法类的实例在策略模式中称为策略对象。