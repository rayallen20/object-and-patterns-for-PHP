问题:addUnit()和removeUnit()方法，是局部类不需要的方法。但是我们把这两个方法的实现
放在抽象超类中，这样做是不是使得局部类多了2个冗余方法？
答案:Unit类的透明性。组合模式的原则:局部类和组合类具有同样的接口。所以客户端在得到一个
Unit对象时，知道其中一定包含addUnit()方法。但是光凭这点不能解决问题，因为客户端不知道
调用这个addUnit()方法是否是安全的。
如果将add/remove方法下放到组合类中，就违反了上面所说的组合模式的原则:局部类和组合类具有同样的接口
而且从客户端的角度来看，在使用Unit对象时，甚至不知道这个对象是否有add/remove方法。
于是我们产生了一个两难的问题:将这两个冗余方法留在局部类中，没有意义且给系统的设计产生一个歧义:
为什么局部类还能添加/移除局部类？
解决办法:将组合类分解为CompositeUnit子类型。
见代码10.2.3

从代码10.2.3中我们可以看到，客户端代码可以通过getComposite()方法返回的是对象还是null来判断
当前对象是叶子对象还是组合对象。这也就解释了getComposite()方法存在的原因。

问题:addUnit()和removeUnit()不再是局部类和组合类共有的接口，这是否违反了组合模式的原则？
答案:没有。因为addUnit()和removeUnit()本来就不该在组合类中出现。问题中所描述的"共有的接口"，
指的是bombardStrength()方法，而不是addUnit()和removeUnit()方法。

根据这个思路，我们来设计客户端代码 见10.2.3-2

组合模式有什么缺陷？在什么场景下不适用？
1.随着模型变的越来越复杂，我们就必须在组合类中进行越来越多的类型检查。
特殊对象变的越来越多，组合模式就显得弊大于利了。因此，组合模式的适用场景为:
大部分局部对象可互换。

假设:现在有一个Cavalry(骑兵)类的实例，需求规定不能将一匹马放到运兵船上。在组合模式下，
我们必须在TroopCarrier类的addUnit()方法中检测当前Unit对象是否是Cavalry的实例，(使用 instanceof 关键字)
随着模型变的越来越复杂，这种手动检查会变的越来越多。

2.组合操作的成本问题。

在本例中，调用一个Army对象的bombardStrength()方法，这个方法会逐级调用对象树中下级分支的bombardStrength()方法。
如果一个对象树中有大量的子Army对象，这个调用可能会导致系统崩溃。解决这个问题的一个办法是在父级对象中缓存计算结果，
这样可以使后续调用减少开销。但是还要小心地保证这个缓存不会失效。

3.不适宜做持久化操作。(简单理解就是存入数据库不方便)

在组合模式下，我们是通过级联调用来访问整个结构的。因此，按正常途径从数据库构造一个组合结构，
会使用多个昂贵的查询。(结构中每个节点都要查询1次)我们可以给对象树中的每个节点赋一个ID，用来
保证所有组件可以从数据库中一次性查询出来。但是，获得这些ORM对象后，重新组织父子关系并不容易。

组合模式的结构适合持久化为XML，因为XML也是树形结构的。