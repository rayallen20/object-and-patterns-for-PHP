管理一组对象是很复杂的，当对象中可能还包含着他们自己的(此处指的就是其他的)对象时更是如此。
从外部来管理这种结构比较困难。

来看一个问题:在"文明"中，玩家可以再一个由大量区块组成的地图上移动战斗单元。
独立的单元可以被组合起来一起移动、战斗和防守。见代码10.2.1

就目前来看，这个模型是可以满足需求的。但是现在有新的需求:
要求部队(Army)和部队之间可以进行合并和分割。即A的部队可以和B的部队合并为一支部队。
也可以将这支联军拆分成A的部队和B的部队，该怎么办呢？ 见代码10.2.1-2
有了$this->armies属性，就可以实现部队的合并和拆分。但是同时我们还要对defensiveStrength()、
movementRange()(移动范围)等方法做同样的修改。(此时已经有些复杂了)

这个时候，客户又有了新的需求:增加一个类:运兵船(TroopCarrier)。
这个类可以支持最多10个战斗单元(即TroopCarrier对象最多可以容纳10个Unit对象)，
以改进它们在某些地形上的移动范围。显然的，TroopCarrier和Army类相似，
但是movementRange()的实现会有所不同。我们现在可以通过改进Army类来处理TroopCarrier对象，
但是以后可能会出现更多对部队进行组合的需求。此时，就需要一个更灵活的模型了。

实际上，客户端代码并不需要去区分对象是Army、Unit、还是TroopCarrier类型。从功能的角度上说，
它们都是相同的:都需要移动、攻击和防御。这些包含其他对象的对象(Army、TroopCarrier)都需要提供添加
和移除其他对象的方法。

综上所述:移动、攻击、防御这些方法，是Army、TroopCarrier和Unit三个类都有的方法。
添加/移除对象这些方法是Army和TroopCarrier两个类都有的方法。于是我们发现:容器对象(Army和TroopCarrier)
与它们包含的对象(Unit的子类)共享同一个接口，所以它们应该共享同一个类型家族。