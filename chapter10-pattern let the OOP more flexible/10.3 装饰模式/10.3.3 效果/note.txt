个人理解部分开始

装饰者模式的4要素:
1.抽象父类
作用:定义组件和装饰者接口的共同接口

2.组件
组件类是抽象父类的实现类，属于被装饰者。组件类的"共同接口"是整个设计模式中的核心功能。
装饰者类负责扩展这个核心功能。

3.装饰者接口
装饰者接口继承自抽象父类，装饰者接口本身也是抽象类，它有2个要素。
3.1 被定义为protected的一个类属性。这个属性负责承载一个组件对象。它的作用在于:
让装饰者接口这个抽象类的实现类可以在它们自己的的"共同接口"方法中调用到组件对象
的"共同接口"方法，以便扩展每个装饰者自己的功能。
3.2 构造方法 构造方法在形参列表中定义参数类型为抽象父类的一个实例化对象，并将这个
对象赋值给3.1中提到的protected的类属性。作用和3.1中提到的作用相同。

4.装饰者实现类
在实现类中，"共同接口"方法负责调用组件的"共同接口"方法并扩展它的专属这个装饰者的功能。

个人理解部分结束

书中内容
组合和继承通常都是同时出现的。这也就解释了在代码10.3.2-2中，为什么LogRequest类既继承了
ProcessRequest类，又表现为对另一个ProcessRequest对象的封装。

因为装饰对象作为子对象的外包装，所以保持基类(要素1)中的方法尽可能少是很重要的。
如果一个基类具有大量特性，那么装饰对象不得不为它们所包装的对象中所有的public方法加上委托。
当然也可以用一个抽象的装饰类来实现这些委托，不过这仍旧会带来耦合，并可能导致bug的出现。

个人对这段话的理解:

基类中的方法尽可能少:就是说基类中尽量不要出现除了"共同接口"方法外的其他方法。
如果基类中除了共同接口方法外还有很多其他方法，而这些方法不需要装饰，那么在装饰者类中
就会因为这些方法的存在，不得不写很多public的方法，然后分别委托给组件对象的对应方法。
也可以把这一步放在装饰者接口类中来实现，但是这仍旧会导致耦合。
Q:这里的仍旧导致耦合，我没有理解。

个人理解结束

书中内容继续
有些程序员创建的装饰类和它所包含的对象并不是继承自同一个基类。这样做也是可以的。
只要这些装饰类提供同样的接口即可。(即装饰类提供"共同接口"这个原则不变即可)
使用PHP的魔术方法来实现自动委托，可以带来很多好处(例如通过__call()来捕捉装饰类中不存在的方法，
并自动调用子对象对应的相同方法)。但是，这样做会丧失类型检查带来的安全性。

对"丧失类型检查带来的安全性"这句话做解释:
在代码10.3.2和10.3.2-2的客户端代码部分，我们可以看到，由于装饰器的共同接口方法对参数的类型限制，
导致客户端必须传入一个抽象父类的实现类的对象作为参数。如果装饰类接口不继承自抽象父类，
那么就无法在装饰类的共同接口中限制参数类型，因为在这里无法知道要传入的是一个组件对象还是一个装饰者对象。
这就丧失了安全性。
