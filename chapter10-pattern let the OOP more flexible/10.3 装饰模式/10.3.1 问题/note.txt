将所有功能建立在继承体系上回导致系统中的类"爆炸式"增多。
更糟糕的是，当你尝试对继承树上不同分支做相似修改时，代码可能会产生重复。

代码10.3.1中，定义了一个Tile类(区域)。getWealthFactor()方法用于计算当某个
特定区域被玩家占领后的收益。 $wealthFactor代表区域对象的财富系数。当然，Tile
对象还会管理其他数据，例如对图片的引用等。此处保持简单，能说明问题即可。

我们还需要修改Plains对象的行为，用于处理一些自然资源和人类滥用的效果。我们希望
为地表钻石的分布和污染造成破坏建模。此处采用的办法是从Plains对象中派生。

10.3.1中的代码有一个问题:现在有一个区域，既有钻石又被污染了，如何表示这个区域的财富系数？
很明显这种代码组织不能回答这个问题。必须要再创建一个PollutedDiamondPlains类才能回答这个问题。
同理，要引入一个既有钻石又被污染的森林类，情况就会更麻烦。

其实产生的问题是:功能定义完全依赖于继承体系会导致类的数量过多，而且代码会产生重复。