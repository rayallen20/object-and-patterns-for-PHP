这个模式带来了什么好处和问题？
好处:
1.将系统和实现细节分开了。在这个例子中，我们添加或删除任意数量的编码格式，对系统都不会造成影响。
2.对系统中功能相关的元素强制进行组合。例如:使用BloggsCommsManager，只有可能得到BloggsCal数据格式相关的类，不可能得到其他数据格式的类。
问题:
1.添加新产品会很困难。如果我要添加一个新的产品，需要首先创建这个产品的抽象类，然后具体实现产品子类。
进而为了支持产品子类，需要修改创建者和它的每个具体实现。

在这个例子中，我们也可以创建一个方法make()，该方法根据一个标志参数来决定返回什么类型的对象。
这样就不用给每个工厂方法创建独立的方法。即不用使方法和产品1对1了。见代码9.4.3

这样的实现，使得类的接口变的更紧凑了。但是也有不好的地方。
使用工厂方法时，我们定义的接口很清晰，并且所有的工厂子类都要遵循这个接口。
而使用这个make()方法，就必须确保所有的具体创建者(工厂子类)都能支持所有的产品对象。
且我们也引入了平行条件，因为每个具体的工厂子类都必须实现相同的标志检测。
而且客户类(调用创建者类的类)是无法确定具体的创建者是否可以生产所有产品。这是因为make()方法内部是需要对每种情况都进行考虑并作出选择的。

但是也有好处。
这样做我们就可以创建更灵活的创建者了。创建者基类提供make()方法来保证每个产品家族都有一个默认实现。
具体子类可以选择性地改变这个行为。子类实现自己的make()方法，由它来决定生成什么类型的对象。
具体子类也可以自行决定是否在执行了自己的make()方法之后调用父类的make()方法。make()方法也使得创建者更加灵活了。