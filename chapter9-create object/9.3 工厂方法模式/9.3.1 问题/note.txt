假设，现在我们有一个关于个人事务管理的项目。
项目中有一个功能，是管理预约(Appointment)对象。此时我们和第三方建立了关系，
要使用一种叫做BloggsCal的数据格式来和他们交流预约的数据。并且以后可能还会有更多的数据格式。

那么我们首先就可以从接口级别上定义出2个类。
1.数据编码器。功能是将Appointment对象转换为专有的(而不是写死的BloggsCal)数据格式。将这个编码器命名为ApptEncoder类
2.管理员类。调用编码器并使用编码器与第三方通信。我们将管理员类命名为CommsManager

设计模式术语:在这个场景中，CommsManager类叫做创建者(creator)，ApptEncoder类叫做产品(product)。

但是还有一个问题:ApptEncoder类的实例从何而来？
我们可以要求传递ApptEncoder类的实例给CommsManager，但是这并没有回答上面的问题。
所以我们先在CommsManager类中直接实例化BloggsApptEncoder 见代码9.3.1

对于代码9.3.1有一个问题，如果需求发生改变，要求我们使用新的数据格式MegaCal时，该怎么办呢？
我们可以使用以前的策略:在getApptEncoder方法中添加条件语句。见代码9.3.1-2

这样做确实解决了数据格式的问题，以后再有新的格式出现就直接在在getApptEncoder方法中添加一个case子句即可。

但是，对于代码9.3.1-2，产生了新的问题:
1.通过CommsManager类来创建ApptEncoder类的实例时，往往是需要条件的。(即何时我们需要使用MegaCal的数据格式，何时我们需要使用BloggsCal的数据格式)
有时候条件语句会被当做坏的"代码味道"的象征。如果重复的条件语句在项目中到处都是的话，很难维护。
2.如果现在又有了新的需求，要求我们提供预约数据的同时，还要提供对应数据格式的页眉页脚。那我们只能扩展CommsManager类。见代码9.3.1-3

对于代码9.3.1-3，问题就显而易见了:
支持页眉输出，还要再判断一遍数据格式的类型，大量重复的条件判断语句出现了。

总结一下上述问题:
1.在代码运行时我们才能知道要生成的对象的确切类型(即:BloggsApptEncoder或MegaApptEncoder)
2.代码不够灵活。如果此时又加入了一种新的数据格式，那么条件判断语句的大量重复，会使得维护困难。
3.每种数据格式都可以定制特定的功能。目前的代码结构是无法实现的。

而且，我们发现，出现了以前提到过的情况:模拟继承。此时，我们应该使用工厂方法模式，
让我们使用继承和多态来封装具体产品的创建。在本例中，我们应该对每种数据格式创建一个CommsManager的一个子类，
每个子类都实现自己的getApptEncoder方法。