我们从强制控制对象的实例化开始入手。
首先创建一个无法从类的外部来创建实例的类。见代码9.2.2
在这段代码中，Preferences类是完全无法使用的。因为它的构造方法被设置为了private。
客户端代码无法实例化对象。

但是可以使用静态方法和静态属性来间接地实例化对象。见代码9.2.2-2

这样的实现，有什么样的优劣呢？
坏处:可能被误用。在系统中任何地方都可以访问到单例，这就会导致产生一个很难调试的依赖关系。
这里，依赖并不是问题。因为我们每次在声明方法时限制参数类型，就已经产生了依赖。问题在于难以调试。
单例的全局化性质，会使得程序员绕过我们类接口定义的通信线路。当单例被使用时，依赖就隐藏在了方法的内部，
没有出现在方法的声明中。这使得依赖关系难以追踪。

好处:可以避免在系统中传递不必要的对象。因为单例是可以全局访问的。