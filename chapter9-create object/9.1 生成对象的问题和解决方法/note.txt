首先，我们鼓励在类中使用抽象的超类。这使代码更具灵活性。
可以让你在运行时使用从不同的具体子类中实例化的对象。但是这样也有副作用，
那就是对象的实例化被推迟了。(因为是运行时实例化)

来看一个具体例子:见代码9.1
这段代码的问题在于，在NastyBoss类中把Minion类给写死了，也就是说
NastyBoss类现在只能和Minion类产生关系，不能和其他的Employee类的实现产生关系，
降低了代码的灵活性。

可是如果在NastyBoss类中不实例化Minion对象，那么Minion对象是从哪里来的呢？
解决办法:通过在方法声明中限制参数类型来避开这个问题。然后除了在测试时实例化对象，
在其他时候尽量避免提到。
见代码9.1-2

改进之后，虽然NastyBoss类可以和Employee类一起工作，但是我们仍旧没有解决一个问题:
创建对象的策略是什么？换言之就是对象从何而来？

解决方案:把对象实例化的工作委托出来。即:委托一个独立的类或方法来生成Employee对象。
见代码9.1-3

概念:工厂:负责生成对象的类或方法，称为工厂。
一般来讲，在工厂代码中汇看到条件语句。尽管我们希望消除条件语句，
但是生成对象确实需要条件语句。一般来讲这不是什么严重的问题，因为我们
把生成对象的代码都放置在一个地方了。反而避免了在其他需要创建对象的地方
出现这种并行的条件语句。